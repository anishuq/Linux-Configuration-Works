Network tools
=============

Fill in!

Name: A. M. Anisul Huq           
Student number: 82372J


====================================================================

			Notice:


I got the following instructions for this report:

"1.4 Since cse.hut.fi is an alias for wwwcse.cs.hut.fi which is an 
alias for www.cs.hut.fi, the responsible name servers can be seen by 
issuing the command "dig cs.hut.fi NS +noall +answer". -1p


2.2 In the assignment you were supposed to retrieve "the main index 
page of www.tkk.fi." You retrieved the headers for the root page with 
a command, which returned 302 "Moved Temporarily". Instead, you should 
have used the command "HEAD /fi/index/index.html HTTP/1.1", to get 
the headers of the actual main index page. -1p"


I made necessary changes to answers of 1.4 and 2.2 as per
instructed in the email.


=====================================================================


1. Networking basics
==============================================================================


1.1 Using ifconfig(8), find all the active interfaces on your machine.
    [1 p.]

          command: ifconfig

eth0      Link encap:Ethernet  HWaddr 00:16:3E:0E:79:9A  
          inet addr:10.0.19.1  Bcast:10.0.255.255  Mask:255.255.0.0
          inet6 addr: fe80::216:3eff:fe0e:799a/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:6712 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1239 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:482031 (470.7 KiB)  TX bytes:156549 (152.8 KiB)

eth1      Link encap:Ethernet  HWaddr 00:16:3E:3D:A1:B5  
          inet6 addr: fe80::216:3eff:fe3d:a1b5/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:12 errors:0 dropped:0 overruns:0 frame:0
          TX packets:12 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:2520 (2.4 KiB)  TX bytes:2520 (2.4 KiB)

eth2      Link encap:Ethernet  HWaddr 00:16:3E:11:FB:E8  
          inet6 addr: fe80::216:3eff:fe11:fbe8/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:11 errors:0 dropped:0 overruns:0 frame:0
          TX packets:11 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:2178 (2.1 KiB)  TX bytes:2178 (2.1 KiB)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:8 errors:0 dropped:0 overruns:0 frame:0
          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:560 (560.0 b)  TX bytes:560 (560.0 b)




1.2 Using netstat(8) and arp(8), find the mac address of the default
    router of your machine. [1 p.]
    

    command: netstat -r | grep default
    default   10.0.0.1    0.0.0.0    UG   0 0    0 eth0

      
    Command: arp -a
    (10.0.0.1) at 00:16:3E:05:CC:5B [ether] on eth0
    Hence MAC address: 00:16:3E:05:CC:5B 

1.3 From resolv.conf(5), find the default name servers and internet
    domain of your workstation. [1 p.]

    
    command: cat /etc/resolv.conf
    
    ; generated by /sbin/dhclient-script
    search localfarm
    nameserver 130.233.40.5
    nameserver 130.233.192.1
    nameserver 130.233.224.1


    Hence internet domain name: localfarm
    
    nameserver 130.233.40.5
    nameserver 130.233.192.1
    nameserver 130.233.224.1



1.4 Using dig(1), find the responsible name servers for the cse.hut.fi
    domain.  [1 p.]  [Edited]

    [Comment: I edited the command that finds the responsible nameserver
    of cse.hut.fi]
  
    [root@lab1 ~]# dig cs.hut.fi NS +noall +answer
    Note: with the +noall query option I turned off all the results and 
    then turned on only the answer section (+answer) that I want.

    
    cs.hut.fi.              600     IN      NS      sauna.cs.hut.fi.
    cs.hut.fi.              600     IN      NS      ns.niksula.hut.fi.
    cs.hut.fi.              600     IN      NS      ns1.hut.fi.
    cs.hut.fi.              600     IN      NS      ns2.hut.fi.



1.5 Using dig(1), find the responsible mail exchange servers for the
    cse.hut.fi domain. [1 p.] 

    the command is: dig cse.hut.fi MX +noall +answer

    cse.hut.fi.             3465    IN      CNAME   wwwcse.cs.hut.fi.
    wwwcse.cs.hut.fi.       600     IN      CNAME   www.cs.hut.fi.
    www.cs.hut.fi.          600     IN      MX      1 mail.cs.hut.fi.
   

2. Examining the request and response messages of clients and servers
speaking a simple, text-based protocol, using HTTP and part of SSH
protocols as an example.
==============================================================================


2.1 Using netcat, nc(1), capture the version number of the ssh daemon
    running on your machine. [1 p.]
	
    command: nc -v localhost 22
    SSH-2.0-OpenSSH_4.3


2.2 Using netcat, nc(1), craft a valid http/1.1 request for getting
    http headers (not the html file itself!) for the main index page
    of www.tkk.fi.  What request method did you use? Which headers did
    you need to send to the server?  What was the status code for the
    request? Which headers did the server return?  Explain the purpose
    of each header. [2 p.] [Edited]

    [Comment: I edited the command that gets the http headers 
     for the main index page of www.tkk.fi. and also added source.]

    [root@lab1 ~]# echo -e "HEAD /fi/index/index.html HTTP/1.1\nHost:www.tkk.fi\n" | nc www.tkk.fi 80
    HTTP/1.0 301 Moved Permanently
    Date: Thu, 14 Jan 2010 02:22:17 GMT
    Server: Apache/2.2.3 (Red Hat)
    X-Powered-By: PHP/5.1.6
    Location: /fi/index/index/
    Cache-Control: max-age=3600
    Expires: Thu, 14 Jan 2010 03:22:17 GMT
    Content-Type: text/html; charset=utf-8
    Age: 1092
    X-Cache: HIT from buster.hut.fi
    X-Cache-Lookup: HIT from buster.hut.fi:80
    Via: 1.0 buster.hut.fi:80 (squid/2.6.STABLE6)
    Connection: close




    I used "HEAD" as request method.

    I needed to send the "Host" header to the server.

    The status code for the requst is 301 which means that the URL has moved permanently.	

   
    The purposes of the returned headers are as following:
    Server: Shows the server name and version number,
    
    X-Powered-By: it lists the version of php running on the server to generate the php page. 

    Age: shows the age of the document.
    
    Cache-Control: it allows a client or server to transmit a
    variety of directives in either requests or responses.    
    
    Location: is used to redirect the recipient
    to a location other than the request-URI for completion of the
    request or identification of a new resource.

    Expires: it gives the date/time after which the
    response is considered invalid.

    Content-Type: Shows the media type.

    X-Cache: proxy has a valid copy of the page in its cache (HIT from buster.hut.fi). 

    X-Cache-Lookup: the page can be showed from the browser's own web cache. But the proxy can also serve the page if             
    needed.

    Connection: the "close" connection option from the sender 
    signals that the connection will be closed after completion of the
    response.

    
    [Added:]
    Source: http://anothersysadmin.wordpress.com/2008/04/22/x-cache-and-x-cache-lookup-headers-explained/
 

2.3 Using netcat, nc(1), start a bogus web server listening on the
    loopback interface port 8080. Verify with netstat(8), that the
    server really is listening where it should be. Direct your browser
    to the bogus server and capture the User-Agent: header. [2 p.]

     For running a web server the command is:
     while true; do nc -l 8080  < somepage.html; done
     Note: somepage.html is constructed by me.
     
    
     the command is: netstat -an | grep 8080
     tcp  0   0 0.0.0.0:8080    0.0.0.0:*       LISTEN	
     
     installed lynx with the command: yum install lynx
     opened the page with: lynx http://localhost:8080
     	
     the user agent header looks like:
     User-Agent header (!): Lynx/2.8.5rel.1 libwww-FM/2.14 SSL-MM/1.4.1 OpenSSL/0.9.8e-fips-rhel5_

2.4 With a similar setup to 2.3, startup a bogus ssh server and try to
    connect to it with ssh(1). Copy-paste the server version string
    you captured in 2.1 and see if you get a response from the
    client. What is the client trying to negotiate? [2 p.]
    
    started the bogus SSH server at port 5001 by:
    nc -l 5001

    ssh -v 10.0.19.1 -p 5001

    Now on the server side I copy-pasted:SSH-2.0-OpenSSH_4.3 
    

    SSH-2.0-OpenSSH_4.3
ÄzNjth
      Cã©%f¸Ydiffie-hellman-group-exchange-sha1,diffie-hellman-group14-sha1,diffie-hellman-group1-sha1ssh-rsa,ssh-dsses128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour128,arcfour256,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctres128-cbc,3des-cbc,blowfish-cbc,cast128-cbc,arcfour128,arcfour256,arcfour,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se,aes128-ctr,aes192-ctr,aes256-ctrUhmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96Uhmac-md5,hmac-sha1,hmac-ripemd160,hmac-ripemd160@openssh.com,hmac-sha1-96,hmac-md5-96none,zlib@openssh.com,zlibnone,zlib@openssh.com,zlibVT102


The above is known as protocol identification phase. When a client tries to connect with a server, the server accepts the connection and then responds by sending back it's own version identification string. The client parses the server's identification string and sends back it's own identification to the server. These identification strings are used to ensure that connection was made to the correct port and also to declare the protocol version and software version number used on both sides.  If either side fails to understand or support each other's versions then the connection is closed. After this phase, the server sends host key, server key and some other information to the client. Finally, the client generates encrypted session key and sends it to the server.

==========================================================================


3. Examining the connection setup more closely.
==============================================================================


3.1 Using xinetd(8), startup a telnetd(8) server, if it's not already
    running.  Also start capturing traffic on the loopback interface
    with tshark(1). Connect to the server with a telnet(1)
    client. What kind of option negotiation (in Telnet Data packets)
    are the server and the client going through? Find the rfc
    describing the options, and explain in your own words, what do
    they agree upon echoing characters (pay attention to port numbers
    for direction of the messages). [4 p.]
    
    
     command: service xinetd start
     Starting xinetd: 

     I enabled telnetd in xinetd. I did it manually by editing /etc/xinetd.d/telnet 
     with nano (nano /etc/xinetd.d/telnet)
     and have made "disabled = yes" to "disabled = no".     

     /etc/init.d/xinetd restart 
     Stopping xinetd:                                   [  OK  ]
     Starting xinetd:                                   [  OK  ]

     to check if telnet is running I used: 
     ps aux | grep telnet
     output: 
     root     15788  0.0  0.5  63880  1344 pts/2    S+   12:33   0:00 nano /etc/xinetd.d/telnet

     
    Start the tshark to monitor loopback interface:
    tshark -i lo -V port 23 > port23output.txt
	
    then clinet connects to server by:
    telnet 127.0.0.1 23


    Option negotiations:
    127.0.0.1 ->  127.0.0.1 (as we are using loopback interface)
 

Telnet
    Command: Do Terminal Type
    Server is willing to receive terminal type information in a
    subsequent sub-negotiation [rfc-1091].   
    

    Command: Do Terminal Speed
    Server is willing to send terminal speed information in a
    subsequent sub-negotiation [rfc-1079].


    Command: Do X Display Location
    Server is willing to receive the X display location in a
    subsequent sub-negotiation [rfc-1096].

    Command: Do New Environment Option
    Server is willing to receive environment
    variables [rfc-1572].


    Source: 127.0.0.1 (127.0.0.1)
    Destination: 127.0.0.1 (127.0.0.1)
    Transmission Control Protocol, Src Port: telnet (23), Dst Port: 47861 (47861), Seq: 1, Ack: 1, Len: 12
    Source port: telnet (23)
    Destination port: 47861 (47861)



Telnet
    Command: Will Terminal Type
    Client is willing to send terminal type information in a
    subsequent sub-negotiation [rfc-1091].

    Command: Will Terminal Speed
    Client is willing to send terminal speed information in a
    subsequent sub-negotiation [rfc-1079].

    Command: Won't X Display Location
    Client refuses to send the X display location [rfc-1096].


    Command: Will New Environment Option
    Client is willing to send new environment
    variables [rfc-1572].


    Source: 127.0.0.1 (127.0.0.1)
    Destination: 127.0.0.1 (127.0.0.1)
    Transmission Control Protocol, Src Port: 47861 (47861), Dst Port: telnet (23), Seq: 1, Ack: 13, Len: 12
    Source port: 47861 (47861)
    Destination port: telnet (23)


Telnet
    Suboption Begin: Terminal Speed
        Option data
    Command: Suboption End
    Server is willing to know the terminal speed of the client.     


    Suboption Begin: New Environment Option
        Option data
    Command: Suboption End
    Server is willing to know the new environment option of the client.

    Suboption Begin: Terminal Type
        Send your Terminal Type
    Command: Suboption End
    Server is willing to know the terminal type of client. 

    Source: 127.0.0.1 (127.0.0.1)
    Destination: 127.0.0.1 (127.0.0.1)
    Transmission Control Protocol, Src Port: telnet (23), Dst Port: 47861 (47861), Seq: 13, Ack: 13, Len: 18
    Source port: telnet (23)
    Destination port: 47861 (47861)


Telnet
    Suboption Begin: Terminal Speed
        Option data
    Command: Suboption End
    Client is willing to know the terminal speed of the server.     


    Suboption Begin: New Environment Option
        Option data
    Command: Suboption End
    Client is willing to know the new environment option of the server.     


    Suboption Begin: Terminal Type
        Here's my Terminal Type
        Value: VT100
    Command: Suboption End
    Client sends information about the terminal type negotiation .
   
    Source: 127.0.0.1 (127.0.0.1)
    Destination: 127.0.0.1 (127.0.0.1)
    Transmission Control Protocol, Src Port: 47861 (47861), Dst Port: telnet (23), Seq: 13, Ack: 31, Len: 34
    Source port: 47861 (47861)
    Destination port: telnet (23)


Telnet
    Command: Will Suppress Go Ahead
    Server is suppressing the Go Ahead command. Server also expects the other party to do the same.
    [rfc-858].


    Command: Do Echo
    Here client receives a "DO ECHO" command. Hence server wants client to start echoing [rfc-857].
    

    Command: Do Negotiate About Window Size
    Sent by the Telnet server to client to suggest that negotiate about window size takes place [rfc-1073].

    Command: Will Status
    Server will perform current status of telnet options and gives permission to client to check the status.
    [rfc-651].


    Command: Do Remote Flow Control
    Server is willing to send commands to enable flow control [rfc-1372].


    Source: 127.0.0.1 (127.0.0.1)
    Destination: 127.0.0.1 (127.0.0.1)
    Transmission Control Protocol, Src Port: telnet (23), Dst Port: 47861 (47861), Seq: 31, Ack: 47, Len: 15
    Source port: telnet (23)
    Destination port: 47861 (47861)
   


Telnet
    Command: Do Suppress Go Ahead
    Client is suppressing the Go Ahead command. Client also expects that server will do the same [rfc-858].


    Command: Won't Echo
    Client refuses to start echoing the data characters [rfc-857].
    
   
    Command: Will Negotiate About Window Size
    Telnet client is willing to negotiate about window Size [rfc-1073].    


    Suboption Begin: Negotiate About Window Size
        Width: 80
        Height: 27
    Command: Suboption End
    
    Client sends window size information to server.


    Command: Do Status
    Client is performing current status of options and wishes the server to do the same [rfc-651].

    Command: Will Remote Flow Control
    Client is willing to negotiate about flow control [rfc-1080].

    
    Source: 127.0.0.1 (127.0.0.1)
    Destination: 127.0.0.1 (127.0.0.1)
    Transmission Control Protocol, Src Port: 47861 (47861), Dst Port: telnet (23), Seq: 47, Ack: 46, Len: 24
    Source port: 47861 (47861)
    Destination port: telnet (23)

Telnet
    Command: Do Echo
    Here server receives a "DO ECHO" command. Hence client wants server to start echoing [rfc-857].


    Source: 127.0.0.1 (127.0.0.1)
    Destination: 127.0.0.1 (127.0.0.1)
    Transmission Control Protocol, Src Port: 47861 (47861), Dst Port: telnet (23), Seq: 71, Ack: 120, Len: 3
    Source port: 47861 (47861)
    Destination port: telnet (23)


Telnet
    Command: Will Echo
    Server would like to echo, so it sends a "WILL ECHO". If its ok with client, then it will "DO ECHO" [rfc-857].


    Source: 127.0.0.1 (127.0.0.1)
    Destination: 127.0.0.1 (127.0.0.1)
    Transmission Control Protocol, Src Port: telnet (23), Dst Port: 47861 (47861), Seq: 46, Ack: 71, Len: 74
    Source port: telnet (23)
    Destination port: 47861 (47861)


    All of the above negotiation took place before login was done. 

4. Improving this assignment (Optional)
==============================================================================


4.1 How would you improve this assignment? You can suggest something
    to be done or asked in the exercise, or something to be left
    out. Please report any errors and typos, and also let us know if
    you did not understand some question. Was the assignment too easy
    or too hard? Estimate also how much time did you spend for this
    assignment.  [2 p.]


    The assignmet is good for introduction to data communication. As an introductory 
    assignment it should have covered some basic Unix commands (e.g. cat, touch, ln, 
    finger, hostname etc.).

    My previous field of work didn't involve any networking in unix environment.
    So I had to learn things from scratch. Also question number 2.4, the term "bogus ssh server" 
    was a bit confusing. From intution, I just started a bogus server with the nc. I don't know 
    if its correct or not. So some clearification would be nice. 
   
    The assignment was neither too easy nor too hard.         

    I have spent close to 15 hours for this assignment. 


